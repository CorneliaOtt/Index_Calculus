#The Algorithm solves the discrete logarithm problem over hyperelliptic curves
#Let q be a prime number, C a hyperellipitc curve over the field F_q, D1 and D2 Divisors in the jacobian of C where 
#D1 is a Divisor of prime order n, D2 is a Divisor in a subgroup of the jacobian generated by D1 
#pollard_rho(n,D_1,D_2) solves D1*n=D_2

def new_x_a_b(x,a,b,n, D1, D2):
    h=hash_divisor(x,3)
    if h%3 ==0:
        x=2*x
        a =  (a*2)  % n
        b =  (b*2)  % n
    if h%3 ==1:
        x=x+D1
        a = (a+1) % n
    if h%3 ==2:
        x=x+D2
        b = (b+1) % n
    return [x,a,b]


def hash_divisor(D,r):
    #hash function h returns values in [0,r-1]
    a=D[0]
    b=D[1]
    if(b!=0):
        h= hash(tuple([a,b]))
    else:
         h= hash(a)
    h=h%r
    return h


def pollard_rho(n,D1,D2):
    while True:
        a=GF(n).random_element()
        b=GF(n).random_element()
        a=Integer(a)
        b=Integer(b)
        x=a*D1+b*D2
        X=x
        A=a
        B=b
        gamma=0
        for i in range (1,n-1):
            [x,a,b]=new_x_a_b( x, a, b, n, D1, D2)
            [X,A,B]=new_x_a_b( X, A, B, n, D1, D2)
            [X,A,B]=new_x_a_b( X, A, B, n, D1, D2)
            if( x == X ):
                if(gcd((B-b),n-1)==1):
                    gamma=((a-A)*inverse_mod((B-b),n))%n
                    if(gamma*D1==D2):
                        return [gamma, B-b, a-A]


#an example
#q=7
#n=119771
#r=log(n,2).round()
#K.<x>=GF(q)[]
#f=2*x^13 + 2*x^12 + 6*x^11 + 3*x^10 + 2*x^8 + x^7 + 2*x^6 + 3*x^5 + 2*x^4 + x^3 + x^2 + 5*x + 4
#h=0
#C=HyperellipticCurve(f,h)
#J=C.jacobian()
#P=C([0,-2,1])
#D_1=J(P)
#D_1
#D_2=12345*D_1
#D_2

#pollard_rho(n,D_1,D_2)









